package org.brokenarrow.lootboxes.builder;import org.bukkit.Material;import org.bukkit.configuration.serialization.ConfigurationSerializable;import org.jetbrains.annotations.NotNull;import java.util.ArrayList;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import java.util.function.Consumer;import static org.brokenarrow.lootboxes.untlity.errors.Valid.checkNotNull;public final class KeysData implements ConfigurationSerializable {  private String keyName;  private String displayName;  private String lootTableLinked;  private int amountNeeded;  private Material itemType;  private List<String> lore;  public KeysData(@NotNull final String keyName,@NotNull final String displayName,@NotNull final String lootTableLinked, final int amountNeeded,@NotNull final String itemType,@NotNull final List<String> lore) {    this(keyName, displayName, lootTableLinked, amountNeeded, retriveMaterial(keyName, itemType), lore);  }  public KeysData(@NotNull final String keyName,@NotNull final String displayName,@NotNull final String lootTableLinked, final int amountNeeded,@NotNull final Material itemType,@NotNull final List<String> lore) {    this.keyName = keyName;    this.amountNeeded = amountNeeded;    this.itemType = itemType;    this.lootTableLinked = lootTableLinked;    this.displayName = displayName;    this.lore = lore;  }  public void updateKeyData(@NotNull final Consumer<KeysDataWrapper> keysDataProvider) {    KeysDataWrapper keysData = new KeysDataWrapper(this);    keysDataProvider.accept(keysData );  }  /**   * Name on the item player get.   *   * @return the display name.   */  @NotNull  public String getDisplayName() {    return displayName;  }  public KeysData setDisplayName(@NotNull String displayName) {    this.displayName = displayName;    return this;  }  /**   * Get the matrial for this key.   *   * @return matrial.   */  @NotNull  public Material getItemType() {    return itemType;  }  public KeysData setItemType(@NotNull final Material itemType) {    this.itemType = itemType;    return this;  }  /**   * Get the key name used internally,   * to keep different keys apart.   *   * @return the key name.   */  @NotNull  public String getKeyName() {    return keyName;  }  public KeysData setKeyName(@NotNull final String keyName) {    this.keyName = keyName;    return this;  }  /**   * Get the amount needed, for open a continer.   *   * @return the amount.   */  public int getAmountNeeded() {    return amountNeeded;  }  public KeysData setAmountNeeded(final int amountNeeded) {    this.amountNeeded = amountNeeded;    return this;  }  /**   * Get the lore for this item.   *   * @return A list.   */  @NotNull  public List<String> getLore() {    return lore;  }  public KeysData setLore(@NotNull final List<String> lore) {    this.lore = lore;    return this;  }  /**   * Get table this key is linked too.   *   * @return the table linked to this key.   */  public String getLootTableLinked() {    return lootTableLinked;  }  /**   * Set the loot-table.   *   * @param lootTableLinked the loot-table linked to this key.   */  public void setLootTableLinked(final String lootTableLinked) {    this.lootTableLinked = lootTableLinked;  }  @Override  public String toString() {    return "KeysToSave{" +            "keyName='" + keyName + '\'' +            ", displayName='" + displayName + '\'' +            ", lootTableLinked='" + lootTableLinked + '\'' +            ", amountNeeded=" + amountNeeded +            ", itemType=" + itemType +            ", lore=" + lore +            '}';  }  /**   * Creates a Map representation of this class.   * <p>   * This class must provide a method to restore this class, as defined in   * the {@link ConfigurationSerializable} interface javadocs.   *   * @return Map containing the current state of this class   */  @NotNull  @Override  public Map<String, Object> serialize() {    Map<String, Object> keysData = new LinkedHashMap<>();    keysData.put("keyName", keyName);    keysData.put("display_name", displayName);    keysData.put("lootTable_linked", lootTableLinked);    keysData.put("amount_of_keys_to_open", amountNeeded);    keysData.put("itemType", itemType + "");    keysData.put("lore", lore);    return keysData;  }  private static Material retriveMaterial(String keyName, final String itemType) {    checkNotNull(itemType, "This item are null. for this key: " + keyName);    Material material = Material.getMaterial(itemType);    checkNotNull(material, "This " + itemType + " are not valid");    return material;  }  public static KeysData deserialize(Map<String, Object> map) {    String keyName = (String) map.get("keyName");    String displayName = (String) map.get("display_name");    if (displayName == null)      displayName = (String) map.getOrDefault("displayName","");    Object lootTableLinkedObj = map.get("lootTableLinked");    String lootTableLinked;    if (lootTableLinkedObj == null)      lootTableLinked = (String) map.get("lootTable_linked");    else      lootTableLinked = (String) lootTableLinkedObj;    Object amountNeededObj = map.get("amountNeeded");    int amountNeeded;    if (amountNeededObj == null)      amountNeeded = (int) map.getOrDefault("amount_of_keys_to_open", 1);    else      amountNeeded = (int) amountNeededObj;    String itemType = (String) map.getOrDefault("itemType","TRIPWIRE_HOOK");    List<?> lore = (List<?>) map.getOrDefault("lore",new ArrayList<>());    return new KeysData(keyName,            displayName,            lootTableLinked,            amountNeeded,            itemType,            (List<String>) lore);  }}